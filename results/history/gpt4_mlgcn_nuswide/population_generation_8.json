{
     "algorithm": "A novel adversarial attack algorithm that combines gradient descent with adaptive momentum accumulation and cosine annealing for efficient generation of adversarial examples targeting specific labels.",
     "code": "import torch\nimport torch.nn as nn\nfrom torch.autograd import Variable\n\n# {A novel adversarial attack algorithm that combines gradient descent with adaptive momentum accumulation and cosine annealing for efficient generation of adversarial examples targeting specific labels.}\n\ndef gen_adv_examples(org_img, target_model, target):\n    adv_img = Variable(org_img.data, requires_grad=True)\n    maxiter = 30\n    epsilon = 0.3\n    alpha = 0.002\n    momentum = torch.zeros_like(org_img)\n    loss_func = nn.BCELoss(reduction='mean')\n\n    for i in range(maxiter):\n        output = target_model(adv_img)\n        loss = -loss_func(output, target.float())\n        target_model.zero_grad()\n\n        if adv_img.grad is not None:\n            adv_img.grad.data.zero_()\n\n        loss.backward()\n\n        # Accumulate momentum with decay\n        momentum_decay = 0.8\n        momentum = momentum_decay * momentum + adv_img.grad / torch.norm(adv_img.grad, p=2, dim=[1,2,3], keepdim=True)\n\n        # Cosine annealing for adaptive step size\n        adaptive_alpha = alpha * (1 + torch.cos(torch.tensor(i / maxiter * 3.1415926535)))\n\n        # Update adversarial image\n        adv_img = adv_img + adaptive_alpha * momentum.sign()\n\n        # Clip to ensure perturbation is within epsilon bounds\n        adv_img = torch.clamp(adv_img, org_img - epsilon, org_img + epsilon)\n\n        # Ensure the pixel values are valid\n        adv_img = torch.clamp(adv_img, 0, 1)\n\n        adv_img = Variable(adv_img.data, requires_grad=True)\n\n    return adv_img",
     "objective": 130.19152,
     "other_inf": null
}